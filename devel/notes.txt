Examples:

    revs & ReidDennis

        +   *.tif
        1   checksums.txt
        1   manifest.csv

        file:
          name: checksums.txt
        file:
          name: manifest.csv
        files:
          pattern: *.tif

    rumsey

        +   DRUID/
        +     *.tif
        1     descMetadata.xml

        dirs:
          re: DRUID
          file:
            name: descMetadata.xml
          files:
            pattern: *.tif

    gould

        +   BARCODE/
        1     00/
        +       *.jpg

        dirs:
          re: BARCODE
          dir:
            name: 00
            files:
              pattern: *.jpg

    AP & Hummel

        +   DRUID/
        1     00/
        +       *.tif
        1     01/
        +       *.jpg
        1     02/
        +       *.jp2
        1     03/
        +       *.jpg
        1     05/
        +       *.jpg

        dirs:
          re: DRUID
          dirs:
            re: 0[1235]
            files:
              pattern: *.tif

    SOHP

        Images
            bc006dj2846_111_img_1.jpg
            bc006dj2846_111_img_1.jpg.md5
            bc006dj2846_111_img_2.jpg
            bc006dj2846_111_img_2.jpg.md5
        PM
            bc006dj2846_111_a_pm.wav
            bc006dj2846_111_a_pm.wav.md5
            bc006dj2846_111_b_pm.wav
            bc006dj2846_111_b_pm.wav.md5
        SH
            bc006dj2846_111_a_sh.wav
            bc006dj2846_111_a_sh.wav.md5
            bc006dj2846_111_b_sh.wav
            bc006dj2846_111_b_sh.wav.md5
        SL
            bc006dj2846_111_a_sl.mp3
            bc006dj2846_111_a_sl.mp3.md5
            bc006dj2846_111_a_sl_techmd.xml
            bc006dj2846_111_b_sl.mp3
            bc006dj2846_111_b_sl.mp3.md5
            bc006dj2846_111_b_sl_techmd.xml
        preContentMetadata.xml


        dirs:
          re: /^(\w{11})$/
          eval: druid = self.name
          file:
            name: preContentMetadata.xml
          dir:
            name: Images
            files:
              re: ^(#{druid}_\d+_)img(\d+).jpg$
              file:
                name: #{parent.basename + '.md5'}
              eval: druid_n = self.match_data[1]
          dir:
            name: 'SH'
          dir:
            name: 'SL'
          dir:
            name: 'PM'
            files:
              re: ^(#{druid_n}_\w+)_pm.wav$
              eval: prefix = self.match_data[1]
              file:
                name: #{prefix + '.md5'}
              file:
                name: #{File.join '..', 'SL', prefix, '_sl.wav'}
                name: #{File.join '..', 'SL', prefix, '_sl.wav.md5'}
                name: #{File.join '..', 'SL', prefix, '_sl.techmd.xml'}
                name: #{File.join '..', 'SH', prefix, '_sl.wav'}
                name: #{File.join '..', 'SH', prefix, '_sl.wav.md5'}


    Paired files

        *.xlsx
        *.docx   # Paired with Excel files.


        files:
          pattern: *.xlsx
          file:
            pattern: #{parent.basename}.docx


Errors:

    Assertion failed:
      Item existence:
        dir        # n = 1
        file
        dirs       # default n = 1+
          n        # Examples: 0+, 1+, 2, 5-10
        files
          n
      Item name:
        name
        re
        pattern

    Extra item found.
      # Allow users to opt out of this check.

Other info:

  Tallies:
    N of files
    N of dirs
    Total size.   # Not by default.

  Tree output?  # Probably not.


Path handling:
  - User always supplies relative name, regex, and pattern values (relative
    to the cwd of the parent Validator).
  - When the catalog is built the root_parent.path is stripped from all paths.

Validator
  # Validator objects are created when user calls:
  #   file()
  #   files()
  #   dir()
  #   dirs()
  #   validator()

  # Existence assertions.
  # By default a Validator does not assert the existence of any
  # files or directory. Such validators merely serve as containers
  # for other validators.
  type           # :file, :dir. Default = :validator.
  n              # 1, 2, 5-8, 0-1, 1+, 0+.
                 # Defaults:
                 #   validator()     0
                 #   file(), dir()   1
                 #   files(), dirs() 1+

  # Name assertions.
  # These parameters provide the user with several syntaxes for
  # making assertions about file and directory names.
  # They will be implemented as regexes.
  name           # Users supplies literal name. Requires n = 1.
  re             # User can supply String or Regexp.
  pattern        # Similar to glob() syntax.
  regex          # The name assertion converted to a Regexp.

  # Attributes common to all Validators.
  #   - The Validator hierarchy.
  parent         # Parent Validator.
  root_parent    # The top-level Validator.
  validators     # Array of child Validators.

  #   - Paths.
  root_dir       # root_parent.cwd.
  cwd            # Current working dir of the Validator. 
                 # Equal to parent.path, with special handling for the root_parent.
  path           # 

  #   - Information held by the root_parent.
  catalog        # Catalog
  warnings

Validator.new('tmp')    #1 root
  file:                 #2
    name: bar.xml
  dirs:                 #3
    re: DRUID
    file:               #4a, 4b, 4c
      re: foo.

    DRUID1/
      foo1a
    DRUID2/
    DRUID3/
      foo3a
      foo3b
    xxx.txt
    yyy.doc
    bar.xml

Validator #1

  get-contents  # From dir-read
    DRUID1/
    DRUID2/
    DRUID3/
    xxx.txt
    yyy.doc
    bar.xml

  check-validator-type :validator
    recurse on child validators

Validator #2

  get-contents  # From parent's dir-read
    DRUID1/
    DRUID2/
    DRUID3/
    xxx.txt
    yyy.doc
    bar.xml

  check-validator-type :file
    matches = find-regex-matching-contents
    matches = find-type-matching-contents of matches
      bar.xml

    check-quantity-assertion

    for M in matches
      M.mark-as-matched
      recurse on child validators  # None in this case.

Validator #3

  get-contents  # Still from parent's dir-read
    DRUID1/
    DRUID2/
    DRUID3/
    xxx.txt
    yyy.doc
    bar.xml   # Matched.

  check-validator-type :dir
    matches = find-regex-matching-contents
    matches = find-type-matching-contents of matches
      DRUID1/
      DRUID2/
      DRUID2/

    check-quantity-assertion

    for M in matches
      M.mark-as-matched
      recurse on child validators

Validator #4a

  setup
    cwd = parent.cwd/DRUID1

  get-contents   # Fresh dir-read.
    foo1a



====================


Validator.new('tmp')    #1 root
  file:                 #2
    name: bar.xml
  dirs:                 #3
    re: DRUID
    file:               #4a, 4b, 4c
      re: foo.


bar.xml           #a
DRUID/            #b
DRUID/foo.        #c

DRUID1/           #b
DRUID1/foo1a      #c
DRUID2/           #b
DRUID3/           #b
DRUID3/foo3a      #c
DRUID3/foo3b      #c
bar.xml           #a
xxx.txt
yyy.doc


=======================
